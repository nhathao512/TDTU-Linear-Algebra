# -*- coding: utf-8 -*-
"""Lab07.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CkABBecu98urjvXCtEcvbZYmMJhnvkn3
"""

#Exercise 1:
import numpy as np
import sympy as sp
#a
print('a)')
v1 = np.array([1, 2, 3, 4])
v2 = np.array([-1, 0, 1, 3])
v3 = np.array([0, 5, -6, 8])

w1 = np.array([3, -6, 17, 11])

A1 = np.transpose([v1, v2, v3])
print(A1)
print()
Aw1 = np.column_stack((A1, w1))
print(Aw)
a = np.linalg.matrix_rank(A1)
b = np.linalg.matrix_rank(Aw1)
if (a == b):
  print("w is linear combination of v1 v2 v3")
else:
  print("w is not linear combination of v1 v2 v3")

#b
print()
print('b)')
v1 = np.array([1, 1, 2, 2])
v2 = np.array([2, 3, 5, 6])
v3 = np.array([2, -1, 3, 6])

w2 = np.array([0, 5, 3, 0])

A2 = np.transpose([v1, v2, v3])
print(A2)
print()
Aw2 = np.column_stack((A2, w2))
print(Aw)
a = np.linalg.matrix_rank(A2)
b = np.linalg.matrix_rank(Aw2)
if (a == b):
  print("w is linear combination of v1 v2 v3")
else:
  print("w is not linear combination of v1 v2 v3")

#c
print()
print('c)')
v1 = np.array([1, 1, 2, 2])
v2 = np.array([2, 3, 5, 6])
v3 = np.array([2, -1, 3, 6])

w3 = np.array([-1, 6, 1, -4])

A3 = np.transpose([v1, v2, v3])
print(A3)
print()
Aw3 = np.column_stack((A3, w3))
print(Aw3)
a = np.linalg.matrix_rank(A3)
b = np.linalg.matrix_rank(Aw3)
if (a == b):
  print("w is linear combination of v1 v2 v3")
else:
  print("w is not linear combination of v1 v2 v3")

#d
print()
print('d)')
v1 = np.array([1, 2, 3, 4])
v2 = np.array([-1, 0, 1, 3])
v3 = np.array([0, 5, -6, 8])
v4 = np.array([1, 15, -12, 8])

w4 = np.array([0, -6, 17, 11])

A4 = np.transpose([v1, v2, v3, v4])
print(A4)
print()
Aw4 = np.column_stack((A4, w4))
print(Aw4)
a = np.linalg.matrix_rank(A4)
b = np.linalg.matrix_rank(Aw4)
if (a == b):
  print("w is linear combination of v1 v2 v3 v4")
else:
  print("w is not linear combination of v1 v2 v3 v4")
print()

#Exercise 2:
import numpy as np
#a
print('a)')
v1 = np.array([1, -2, 0]).T
v2 = np.array([0, -4, 1]).T
v3 = np.array([1, -1, 1]).T

A1 = np.column_stack([v1, v2, v3])
print(A1)
r1 = np.linalg.matrix_rank(A1)
if r1 == len(A1):
  print("Vectors are linearly independent")
else:
  print("Vectors are not linearly independent")
#b
print()
print('b)')
v1 = np.array([1, 0, 2]).T
v2 = np.array([0, 1, 4]).T
v3 = np.array([2, -2, -4]).T

A2 = np.column_stack([v1, v2, v3])
print(A2)
r2 = np.linalg.matrix_rank(A2)
print(r2)
if r2 == len(A2):
  print("Vectors are linearly independent")
else:
  print("Vectors are not linearly independent")


#c
print()
print('c)')
v1 = np.array([1, -2, 3, 4])
v2 = np.array([2, 4, 5, 0])
v3 = np.array([-2, 0, 0, 4])
v4 = np.array([3, 2, 1, -1])

A3 = np.column_stack([v1, v2, v3, v4])
print(A3)
r3 = np.linalg.matrix_rank(A3)
if r3 == len(A3):
  print("Vectors are linearly independent")
else:
  print("Vectors are not linearly independent")
#d
print()
print('d)')
v1 = np.array([0, 0, 1, 2, 3])
v2 = np.array([0, 0, 2, 3, 1])
v3 = np.array([1, 2, 3, 4, 5])
v4 = np.array([2, 1, 0, 0, 0])
v5 = np.array([-1, -3, -5, 0, 0])

A4 = np.column_stack([v1, v2, v3, v4, v5])
print(A4)
r4 = np.linalg.matrix_rank(A4)
if r4 == len(A4):
  print("Vectors are linearly independent")
else:
  print("Vectors are not linearly independent")

#Exercise 3:
import numpy as np

C = np.array([[1, 0, 2, 3],[4, -1, 0, 2],[0, -1, -8, -10]])
#a
res = sp.Matrix(C).rref()
print("sp.Matrix(C).rref() = ", res)
basisC = C[:, list(res[1])]
print("A basis for the column space of C = \n", basisC)
# print("We can create the third column of C by the basis:", 2*basisC[:, 0] + 8*basisC[:, 1])

#b
C_T = np.transpose(C)
res_b = sp.Matrix(C_T).rref()
print("sp.Matrix(C).rref() = ", res_b)
basisC_T = C.T[:, list(res[1])]
print("A basis for the column space of C = \n", basisC_T)
# print("We can create the third column of C by the basis:", 2*basisC_T[:, 0] + 8*basisC_T[:, 1])

#Execise 4:
import numpy as np

A = np.array([[1, 0, 2, 3],[4, -1, 0, 2],[0, -1, -8, -10]])
res = sp.Matrix(A).nullspace()
print("res =", res)
basic_null_space_A = np.array(res[0]) #vector v1
for i in range(1, len(res)):
  basic_null_space_A = np.hstack((basic_null_space_A, np.array(res[i])))

print("\n a basis for the null-space of A =\n", basic_null_space_A)
#check the null-space result
print("\n A x null[0]=", np.matmul (A, basic_null_space_A[:, 0]))
print("\n A x null[1] =", np.matmul (A, basic_null_space_A[:, 1]))

#Exercise 5:
import numpy as np
A1 = np.array([[7, 6, -4, 1], [-5, -1, 0, -2], [9, -11, 7, -3], [19, -9, 7, 1]])
w1 = np.array([1, 1, -1, -3])

A2 = np.array([[-8, 5, -2, 0], [-5, 2, 1, -2], [10,-8 ,6 ,-3], [3,-2 ,1 ,0]])
w2 = np.array([1 ,2 ,1 ,0])

if np.linalg.matrix_rank(A1) == np.linalg.matrix_rank(np.column_stack((A1,w1))):
    print("w là không gian cột của ma trận A")
else:
    print("w không phải là không gian cột của ma trận A")

if np.allclose(np.dot(A1,w1),0):
    print("w là không gian con của ma trận A")
else:
    print("w không phải là không gian con của ma trận A")

if np.allclose(np.dot(A2,w2),0):
    print("w là null-space của ma trận A")
else:
    print("w không phải là null-space của ma trận A")

#Exercise 6:
import numpy as np
A = np.array([[5, 1, 2, 2, 0], [3, 3, 2, -1, -12], [8, 4, 4, -5, 12], [2, 1, 1, 0, -2]])
B = A[:,[0,1,3]]
a3 = A[:,2]
a5 = A[:,4]

if np.linalg.matrix_rank(B) == np.linalg.matrix_rank(np.column_stack((B,a3))):
    print("a3 nằm trong không gian cột của ma trận B",)
else:
    print("a3 không nằm trong không gian cột của ma trận B")
if np.linalg.matrix_rank(B) == np.linalg.matrix_rank(np.column_stack((B,a5))):
    print("a5 nằm trong không gian cột của ma trận B")
else:
    print("a5 không nằm trong không gian cột của ma trận B")

#Exercise 7:
import numpy as np

A = np.array([[1, 0, 2], [0, 1, 4], [2, -2, -4]])

dim_span = np.linalg.matrix_rank(A)

rref, _ = np.linalg.qr(A)
basis = rref[:, :dim_span]

print("Dimension of span:", dim_span)
print("Basis for span:")
print(basis)

#Exercise 8:
import numpy as np

# Create the Hilbert matrix A with size 5
A = np.array([[1/(i+j-1) for j in range(1,6)] for i in range(1,6)])
print("Hilbert Matrix")
print(A)

# Create matrix B
B = np.zeros((5,5))
for i in range(5):
    for j in range(i+1):
        if j == 0 or j == i:
            B[i][j] = 1
        else:
            B[i][j] = B[i-1][j-1] + B[i-1][j]
print("Pascal Matrix")
print(B)

# Create magic matrix C
n = 5
C = [[0 for x in range(n)] for y in range(n)]

i = n // 2
j = n - 1

num = 1
while num <= (n * n):
    if i == -1 and j == n:
        j = n - 2
        i = 0
    else:
        if j == n:
            j = 0
        if i < 0:
            i = n - 1
    if C[i][j]:
        j -= 2
        i += 1
        continue
    else:
        C[i][j] = num
        num += 1
    j += 1
    i -= 1
arr = np.array(C).flatten()
# Reshape mảng về dạng ma trận vuông
n = int(np.sqrt(len(arr)))
C_square = arr.reshape(n, n)
print("Magic matrix")
print(C_square)

# Find a basis for the null space of Hilbert Matrix
u, s, vh = np.linalg.svd(A)
null_space_basis_A = vh[np.sum(s > 1e-10):,:].T

# Find a basis for the null space of Pascal Matrix
u, s, vh = np.linalg.svd(B)
null_space_basis_B = vh[np.sum(s > 1e-10):,:].T

# Find a basis for the null space of Magic Matrix
u, s, vh = np.linalg.svd(C_square)
null_space_basis_C = vh[np.sum(s > 1e-10):,:].T

print("Basis for the null space of Hilbert Matrix:")
print(null_space_basis_A)

print("Basis for the null space of Pascal Matrix:")
print(null_space_basis_B)

print("Basis for the null space of Magic Matrix:")
print(null_space_basis_C)

#Exercise 9:
import numpy as np
def checkOrthogonalSet (U): # U = (u1, u2, u3, ...)
  for i in range(len(U)):
    for j in range(len(U)):
      if i < j:
        if np.dot(U[i], U[j]) != 0:
          return False
  return True
U = ([1, 2, 3], [1, 1, -1], [5, 4, 1])
print("orthogonal set =", checkOrthogonalSet( U ) )

#Exercise 10:
import numpy as np

def orthogonal_projection(y, u):
    projection = np.dot(y, u) / np.dot(u, u) * u
    return projection

y = np.array([7, 6])
u = np.array([4, 2])

proj_u_y = orthogonal_projection(y.T, u.T)
print("The orthogonal projection of y onto u is:", proj_u_y)

#Exercise 11:
import numpy as np
def checkOrthonormalColumns (U):
  return np.allclose(np.matmul (U.T, U), np.eye (U.shape[1]))
a = np. pi/2
U = np.array([
    [np.cos (a), -np.sin(a)],
    [np.sin(a), np.cos(a)]
])
print("U =\n", U)
print("CheckOrthonormalColumns =", checkOrthonormalColumns (U))

#Exercise 12:
from scipy.linalg import orth
C = np.array([[-10, 13, 7, -11], [2, 1, -5, 3], [-6, 3, 13, -3], [16, -16, -2, 5], [2, 1, -5, -7]])
print("An orthogonal basis for column space of C =\n", orth (C))